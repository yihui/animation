a:67:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:0;}i:2;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1;}i:3;a:3:{i:0;s:12:"section_edit";i:1;a:4:{i:0;i:-1;i:1;i:0;i:2;i:1;i:3;s:0:"";}i:2;i:1;}i:4;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:52:"The Bisection Method for Root-finding on an Interval";i:1;i:1;i:2;i:1;}i:2;i:1;}i:5;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:6;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:67;}i:7;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:180:"
In mathematics, the bisection method is a root-finding algorithm which works by repeatedly dividing an interval in half and then selecting the subinterval in which a root exists. ";}i:2;i:68;}i:8;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:248;}i:9;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:248;}i:10;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:38:"Suppose we want to solve the equation ";}i:2;i:250;}i:11;a:3:{i:0;s:6:"plugin";i:1;a:3:{i:0;s:9:"mathmulti";i:1;a:2:{i:0;s:6:"normal";i:1;s:20:"\normalsize f(x) = 0";}i:2;i:5;}i:2;i:288;}i:12;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:". Given two points ";}i:2;i:298;}i:13;a:3:{i:0;s:6:"plugin";i:1;a:3:{i:0;s:9:"mathmulti";i:1;a:2:{i:0;s:6:"normal";i:1;s:13:"\normalsize a";}i:2;i:5;}i:2;i:317;}i:14;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" and ";}i:2;i:320;}i:15;a:3:{i:0;s:6:"plugin";i:1;a:3:{i:0;s:9:"mathmulti";i:1;a:2:{i:0;s:6:"normal";i:1;s:13:"\normalsize b";}i:2;i:5;}i:2;i:325;}i:16;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:" such that ";}i:2;i:328;}i:17;a:3:{i:0;s:6:"plugin";i:1;a:3:{i:0;s:9:"mathmulti";i:1;a:2:{i:0;s:6:"normal";i:1;s:16:"\normalsize f(a)";}i:2;i:5;}i:2;i:339;}i:18;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" and ";}i:2;i:345;}i:19;a:3:{i:0;s:6:"plugin";i:1;a:3:{i:0;s:9:"mathmulti";i:1;a:2:{i:0;s:6:"normal";i:1;s:16:"\normalsize f(b)";}i:2;i:5;}i:2;i:350;}i:20;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:69:" have opposite signs, we know by the intermediate value theorem that ";}i:2;i:356;}i:21;a:3:{i:0;s:6:"plugin";i:1;a:3:{i:0;s:9:"mathmulti";i:1;a:2:{i:0;s:6:"normal";i:1;s:13:"\normalsize f";}i:2;i:5;}i:2;i:425;}i:22;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:45:" must have at least one root in the interval ";}i:2;i:428;}i:23;a:3:{i:0;s:6:"plugin";i:1;a:3:{i:0;s:9:"mathmulti";i:1;a:2:{i:0;s:6:"normal";i:1;s:18:"\normalsize [a, b]";}i:2;i:5;}i:2;i:473;}i:24;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:" as long as ";}i:2;i:481;}i:25;a:3:{i:0;s:6:"plugin";i:1;a:3:{i:0;s:9:"mathmulti";i:1;a:2:{i:0;s:6:"normal";i:1;s:13:"\normalsize f";}i:2;i:5;}i:2;i:493;}i:26;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:95:" is continuous on this interval. The bisection method divides the interval in two by computing ";}i:2;i:496;}i:27;a:3:{i:0;s:6:"plugin";i:1;a:3:{i:0;s:9:"mathmulti";i:1;a:2:{i:0;s:6:"normal";i:1;s:27:"\normalsize c = (a + b) / 2";}i:2;i:5;}i:2;i:591;}i:28;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:42:". There are now two possibilities: either ";}i:2;i:608;}i:29;a:3:{i:0;s:6:"plugin";i:1;a:3:{i:0;s:9:"mathmulti";i:1;a:2:{i:0;s:6:"normal";i:1;s:16:"\normalsize f(a)";}i:2;i:5;}i:2;i:650;}i:30;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" and ";}i:2;i:656;}i:31;a:3:{i:0;s:6:"plugin";i:1;a:3:{i:0;s:9:"mathmulti";i:1;a:2:{i:0;s:6:"normal";i:1;s:16:"\normalsize f(c)";}i:2;i:5;}i:2;i:661;}i:32;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:25:" have opposite signs, or ";}i:2;i:667;}i:33;a:3:{i:0;s:6:"plugin";i:1;a:3:{i:0;s:9:"mathmulti";i:1;a:2:{i:0;s:6:"normal";i:1;s:16:"\normalsize f(c)";}i:2;i:5;}i:2;i:692;}i:34;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" and ";}i:2;i:698;}i:35;a:3:{i:0;s:6:"plugin";i:1;a:3:{i:0;s:9:"mathmulti";i:1;a:2:{i:0;s:6:"normal";i:1;s:16:"\normalsize f(b)";}i:2;i:5;}i:2;i:703;}i:36;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:124:" have opposite signs. The bisection algorithm is then applied recursively to the sub-interval where the sign change occurs. ";}i:2;i:709;}i:37;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:833;}i:38;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:833;}i:39;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:"The function ";}i:2;i:835;}i:40;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:848;}i:41;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:"bisection.method()";}i:2;i:850;}i:42;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:868;}i:43;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:81:" gives a visual demonstration of this process of finding the root of an equation ";}i:2;i:870;}i:44;a:3:{i:0;s:6:"plugin";i:1;a:3:{i:0;s:9:"mathmulti";i:1;a:2:{i:0;s:6:"normal";i:1;s:20:"\normalsize f(x) = 0";}i:2;i:5;}i:2;i:951;}i:45;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:".";}i:2;i:961;}i:46;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:962;}i:47;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:964;}i:48;a:3:{i:0;s:12:"section_edit";i:1;a:4:{i:0;i:1;i:1;i:963;i:2;i:1;i:3;s:52:"The Bisection Method for Root-finding on an Interval";}i:2;i:964;}i:49;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:9:"Animation";i:1;i:2;i:2;i:964;}i:2;i:964;}i:50;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:964;}i:51;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:985;}i:52;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:"
";}i:2;i:986;}i:53;a:3:{i:0;s:6:"plugin";i:1;a:3:{i:0;s:9:"animation";i:1;a:2:{i:0;i:1;i:1;a:7:{i:0;s:2:"bm";i:1;s:67:"http://i288.photobucket.com/albums/ll181/xieyihui/bisection_method/";i:2;s:3:"png";i:3;s:2:"11";i:4;s:3:"400";i:5;s:1:"2";i:6;s:52:"The Bisection Method for Root-finding on an Interval";}}i:2;i:1;}i:2;i:987;}i:54;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:"
";}i:2;i:1129;}i:55;a:3:{i:0;s:6:"plugin";i:1;a:3:{i:0;s:9:"animation";i:1;a:2:{i:0;i:3;i:1;a:1:{i:0;s:162:"The bisection method is a root-finding algorithm which works by repeatedly dividing an interval in half and then selecting the subinterval in which a root exists.";}}i:2;i:3;}i:2;i:1130;}i:56;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:"
";}i:2;i:1292;}i:57;a:3:{i:0;s:6:"plugin";i:1;a:3:{i:0;s:9:"animation";i:1;a:2:{i:0;i:4;i:1;a:1:{i:0;s:0:"";}}i:2;i:4;}i:2;i:1293;}i:58;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1299;}i:59;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1301;}i:60;a:3:{i:0;s:12:"section_edit";i:1;a:4:{i:0;i:964;i:1;i:1300;i:2;i:2;i:3;s:9:"Animation";}i:2;i:1301;}i:61;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:6:"R code";i:1;i:2;i:2;i:1301;}i:2;i:1301;}i:62;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:1301;}i:63;a:3:{i:0;s:4:"code";i:1;a:2:{i:0;s:397:"
ani.start(nmax = 50, ani.height = 400, ani.width = 600, interval = 2,
    title = "The Bisection Method for Root-finding on an Interval",
    description = "The bisection method is a root-finding algorithm 
    which works by repeatedly dividing an interval in half and then 
    selecting the subinterval in which a root exists.")
par(mar = c(4, 4, 1, 1))
bisection.method(main = "")
ani.stop()
";i:1;s:1:"r";}i:2;i:1326;}i:64;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1733;}i:65;a:3:{i:0;s:12:"section_edit";i:1;a:4:{i:0;i:1301;i:1;i:0;i:2;i:2;i:3;s:6:"R code";}i:2;i:1733;}i:66;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:1733;}}